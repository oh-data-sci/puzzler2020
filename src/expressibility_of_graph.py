# given a letter, list of allowed letters to follow:
allowed_vertices = {
    'b': ['r','l','o','t','y'],
    'r': ['c','e','o','l','b'],
    'c': ['h','g','o','e','r'],
    'h': ['s','w','o','g','c'],
    's': ['y','n','o','w','h'],
    'y': ['b','t','o','n','s'],
    't': ['b','l','o','n','y'],
    'l': ['r','e','o','t','b'],
    'e': ['r','c','g','o','l'],
    'g': ['e','c','h','w','o'],
    'w': ['o','g','h','s','n'],
    'n': ['t','o','w','s','y'],
    'o': ['b','r','c','h','s', 
          'y','l','e','g','w', 
          'n','t'],
}

# nodes
allowed_tokens = set(next_letter_dict.keys())

# function wrap up
def check_if_expressible(word, allowed_vertices=allowed_vertices, allowed_tokens=allowed_tokens):
    """
    given a string and a graph of allowed token pairings, this function checks whether the string can 
    be formed by traversing the graph of allowed pairs. 
    input: 
        word, a character string.
        next_letter_dict, a dict whose keys are all the allowed tokens, the values are each key's (token's) allowed pairings.
        allowed_tokens, a set of tokens, equal to the keys of the next letter dict.
    output:
        allowed, boolean. true if word can be generated by traversing the graph.
    """
    if not set(word).issubset(allowed_tokens):
        # input word contains tokens not found in graph of allowed pairs.
        allowed = False
    else:
        if len(word) > 1:
            # need to check pairs of tokens
            allowed =True
            first_letter = word[0]
            for second_letter in word[1:]:
                if second_letter not in next_letter_dict[first_letter]:
                    allowed = False
                    break
                first_letter = second_letter
        else:
            allowed = True
    return allowed


def read_word_list(filepath):
    """
    read a system dictionary or other word list file.
    return list of words, stripped of whitespaces
    """
    with open(filepath, 'r') as file:
        word_list= file.readlines()
    return [word.strip() for word in word_list]



def scan_words(word_list, allowed_vertices=allowed_vertices, allowed_tokens=allowed_tokens):
    """
    filter words from a list that are expressible by the graph.
    """
    return [
        word 
        for word in word_list
        if check_if_expressible(word, allowed_vertices=allowed_vertices, allowed_tokens=allowed_tokens)
    ]
            

import random
def main():
    words = read_word_list('../data/words.txt')
    print('word list `words` contains', len(words), 'words, e.g.', random.sample(words, 5))
    allowed_words = scan_words(words)
    print('of which', len(allowed_words), 'can be formed using graph')
    long_allowed = [word for word in allowed_words if len(word)>6]
    print('of which', len(long_allowed), 'are long')
    print('for example:', random.sample(long_allowed, 4))
    max_length = 5
    for word in long_allowed:
        word_length = len(word)
        if word_length > max_length:
            longest_word = word
            max_length = word_length
    print('and the longest word found was', longest_word, '(',  max_length, 'letters )')
    
if __name__ == "__main__":
    main()
